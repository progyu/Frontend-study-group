# 자바스크립트 개발 환경과 실행 방법



## 1. 자바스크립트 실행 환경

모든 브라우저는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다. 브라우저뿐만아니라 Node.js도 자바스크립트 엔진을 내장하고 있다. 따라서 자바스크립트는 브라우저와 Node.js 환경에서 실행할 수 있다. 

브라우저와 Node.js는 존재 목적이 다르다. 브라우저는 HTML, CSS, 자바스크립트를 실행하여 웹페이지를 화면에 렌더링하는 것이 주된 목적이지만, Node.js는 서버 개발 환경은 제공하는 것이  주된 목적이다. 따라서 브라우저와 Node.js 모두 자바스크립트의 코어인 ECMAScript를 실행할 수 있지만 브라우저와 Node.js에서 ECMAScript 이외에 추가적으로 제공하는 기능은 호환되지 않는다.

예를 들어, Node.js는 DOM API를 제공하지 않는다. 서버에서는 HTML 요소를 객체화한 DOM(Document Object Model)을 직접 다룰 필요가 없기 때문이다.



## 2. 웹 브라우저

### 2.1 웹 브라우저는 어떻게 동작하는가?

**브라우저의 핵심 기능**은 사용자가 참조하고자 하는 웹 페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저는 서버로부터 HTML, CSS, 자바스크립트, 이미지 파일 등을 응답 받는다. HTML, CSS 파일은 `렌더링 엔진`의 `HTML 파서`와 `CSS 파서`에 의해 파싱(Parsing)되어 `DOM`, `CSSOM` 트리로 변환되고 `렌더 트리`로 결합된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다.

**자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다.** **HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.**

자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.

이처럼 브라우저는 **동기(Synchronous)적**으로 HTML, CSS, 자바스크립트를 처리한다. 이것은 **script 태그의 위치**에 따라 **블로킹**이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 **script 태그의 위치는 중요한 의미**를 갖는다. 

head 요소 내부에 script 태그를 위치시키면 HTML 요소가 파싱되어 DOM 객체로 변환되기 이전에 자바스크립트가 실행된다. DOM요소를 참조하는 코드가 자바스크립 파일에 있다면 아직 DOM 객체로 변환되지 않은  HTML 요소를 참조하게 되므로 바르게 동작하지 않는다.

따라서, body 요소의 가장 아래에 자바스크립를 위치시키는 것이 좋은 아이디어이다.

-  HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.
- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생한다.



대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 [컴파일러 언어](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC)처럼 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스 코드를 컴파일하고 실행한다.

이를 통해 인터프리터 언어의 장점인 동적 기능 지원을 살리면서 실행 속도가 느리다는 단점을 극복한다. 따라서 현재는 컴파일러와 인터프리터의 기술적 구분이 점차 모호해져 가는 추세이다. 하지만 자바스크립트는 런타임에 컴파일되며 실행 파일이 생성되지 않고 인터프리터의 도움없이 실행할 수 없기 때문에 컴파일러 언어라고 할 수는 없다.



| 컴파일러                                                     | 인터프리터                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **컴파일 타임에 소스 코드 전체**를 한번에 [머신 코드](https://ko.wikipedia.org/wiki/%EA%B8%B0%EA%B3%84%EC%96%B4)(CPU가 바로 실행할 수 기계어)로 변환한 후 실행한다. | **런타임**에 **문 단위로 한 줄씩** 중간 코드인 [바이트 코드](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C)(특정한 하드웨어가 아니라 가상 머신에서 실행하도록 만든 바이너리 코드)로 변환한 후 실행한다. |
| 실행 파일을 **생성**한다.                                    | 실행 파일을 **생성하지 않는다.**                             |
| 컴파일 단계와 실행 단계가 분리되어 있다. 명시적인 컴파일 단계를 거쳐서 명시적으로 실행 파일을 실행한다. | **인터프리트 단계와 실행 단계가 분리되어 있지 않다.** 인터프리터는 한 줄씩 바이트 코드로 변환하고 즉시 실행한다. |
| 컴파일은 **단 한번 수행**된다.                               | 코드가 실행될 때마다 **인터프리트 과정이 반복 수행된다.**    |
| 컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠르다. | 인터프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다. |



### 2.2 개발자 도구

| 패널        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| Elements    | 로딩된 웹 페이지의 DOM과 CSS를 편집하여 **렌더링된 뷰를 확인**해 볼 수 있다. 단, 편집한 내용이 저장되지는 않는다. 웹 페이지가 의도된 대로 렌더링되지 않았다면 이 패널을 확인하여 유용한 힌트를 얻을 수 있다. |
| Console     | 로딩된 웹 페이지의 **에러를 확인**하거나 자바스크립트 소스코드에 포함시킨 console.log 메소드의 결과를 확인해 볼 수 있다. |
| Sources     | 로딩된 웹 페이지의 자바스크립트 코드를 **디버깅**할 수 있다. |
| Network     | 로딩된 웹 페이지에 관련한 **네트워크 요청(request) 정보와 퍼포먼스**를 확인할 수 있다. |
| Application | **웹 스토리지, 세션, 쿠키**를 확인하고 관리할 수 있다.       |

콘솔과 디버깅에 대한 보다 자세한 내용은 구글의 [Tools for Web Developers: 콘솔 사용](https://developers.google.com/web/tools/chrome-devtools/console/?hl=ko)과 [Tools for Web Developers: Chrome DevTools에서 자바스크립트 디버깅 시작하기](https://developers.google.com/web/tools/chrome-devtools/javascript/?hl=ko)를 참고하기 바란다.



## 3. Node.js

클라이언트 사이드, 즉 웹 브라우저에서 동작하는 간단한 웹 애플리케이션은 브라우저만으로도 개발을 할 수 있다. 하지만 프로젝트의 규모가 커짐에 따라 React, jQuery와 같은 **외부 라이브러리**를 도입하거나 Babel, Webpack, ESLint 등 **여러 가지 도구를 사용**해야 할 필요가 있다. **이때 Node.js와 npm이 필요하다.**



### 3.1 Node.js와 npm 소개

2009년 [라이언 달(Ryan Dahl)](https://en.wikipedia.org/wiki/Ryan_Dahl)이 발표한 [Node.js](https://nodejs.org/)는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 [런타임 환경(Runtime Environment)](https://ko.wikipedia.org/wiki/%EB%9F%B0%ED%83%80%EC%9E%84)이다. 간단히 말해 **브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경이 Node.js이다.**

Node.js는 주로 서버 사이드 애플리케이션 개발에 사용되며 이에 필요한 모듈, 파일 시스템, HTTP 등 [빌트인 API](https://nodejs.org/dist/latest-v12.x/docs/api)를 제공한다. Node.js는 데이터를 실시간 처리하여 빈번한 I/O가 발생하는 SPA(Single Page Application)에 적합하다. 하지만 CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.

[npm(node package manager)](https://www.npmjs.com/)은 **자바스크립트 패키지 매니저**이다. Node.js에서 사용할 수 있는 **모듈들을 패키지화하여 모아둔 저장소 역할**과 **패키지 설치 및 관리를 위한 CLI(**Command line interface)를 제공한다. 자신이 작성한 패키지를 공개할 수도 있고 필요한 패키지를 검색하여 재사용할 수도 있다.



## 질문

**Q.** 자바스크립트 엔진의 종류?

**A.**

- Rhino - 모질라
- SpiderMonkey - 파이어폭스
- V8 - 구글, 오페라
- JavascriptCore - 사파리
- Chakra - 익스플로러, 마이크로소프트 엣지



**Q.**  렌더링 엔진의 종류?

**A.**  

- Gecko - 모질라, 파이어폭스

- Blink - 구글, 오페라

- Webkit - 사파리

- Trident - 익스플로러

- EdgeHTML - 마이크로소프트 엣지



**Q.** 스크립트가 문서를 파싱하는 동안 스타일 정보를 요청하는 경우 문제가 발생할 수 있는데 이를 브라우저가 해결하는 방법은 무엇인가?

**A.** 게코 엔진은 아직 로드 중이거나 파싱 중인 스타일 시트가 있는 경우 모든 스크립트의 실행을 중단한다. 웹킷 엔진에 경우에는 로드되지 않은 스타일 시트 가운데 문제가 될만한 속성이 있을 때에만 스크립트를 중단한다.



**Q.** <script> 태그를 만나면 HTML 파서는 HTML 문서의 파싱을 일시 중지한 다음 JavaScript 코드를 로딩하고 파싱해 실행해야 한다. 왜 그럴까?

**A.** JavaScript는 DOM 구조 변경할 수 있기 때문.



**Q.**  JavaScript 코드를 비동기적으로 로딩하고 실행하면서 HTML 파싱을 막지 않는 방법은?

**A.**  <script> 태그에 async 속성이나 defer 속성을 추가





## 더나아가기

[브라우저는 어떻게 동작하는가? - NAVER D2](<https://d2.naver.com/helloworld/59361>)

[최신 브라우저의 내부 살펴보기1 - NAVER D2](<https://d2.naver.com/helloworld/2922312>)

[최신 브라우저의 내부 살펴보기3 - NAVER D2](<https://d2.naver.com/helloworld/5237120>)

[자바스크립트엔진](<https://mathiasbynens.be/notes/shapes-ics>)

[리소스 우선순위 지정](<https://developers.google.com/web/fundamentals/performance/resource-prioritization>)



> 이 글은 © 2019  Ung-mo Lee [poiemaweb](<https://poiemaweb.com/>)의 내용을 요약한 것입니다.